{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 168,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Question 5\n",
      "\n",
      "Test Error: 106.38375849934768\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import math\n",
    "from matplotlib import pyplot as plt\n",
    "from data_utils import load_dataset\n",
    "\n",
    "\n",
    "# ALVIN PANE [1004281118]\n",
    "\n",
    "# ROB313\n",
    "\n",
    "#Q1 done on paper\n",
    "Q2 = False\n",
    "Q3 = False\n",
    "Q4 = False\n",
    "Q5 = True\n",
    "\n",
    "#Q2 code ****************************************************************\n",
    "\n",
    "def testGLM(x_train, x_valid, x_test, y_train, y_valid, y_test, lambda_):\n",
    "\n",
    "    x_total = np.vstack([x_train, x_valid])\n",
    "    y_total = np.vstack([y_train, y_valid])\n",
    "    \n",
    "    s = (len(x_total), 7)\n",
    "    phi = np.empty(s)\n",
    "    for i in range(len(x_total)):\n",
    "        phi[i, :] = basisvector(x_total[i]) #phi matrix training\n",
    "\n",
    "    s2 = (len(x_test), 7)\n",
    "    testphi = np.empty(s2)\n",
    "    for i in range(len(x_test)):\n",
    "        testphi[i, :] = basisvector(x_test[i]) #phi matrix test\n",
    "\n",
    "    #SVD\n",
    "    U, S, D = np.linalg.svd(phi)\n",
    "    sig = np.diag(S)\n",
    "    fillzeros = np.zeros([len(x_total) - len(S), len(S)])\n",
    "    sig = np.vstack([sig, fillzeros])\n",
    "\n",
    "    #get predictions\n",
    "    t0 = np.dot(sig.T, sig)\n",
    "    t1 = np.linalg.inv(t0 + lambda_ * np.eye(len(t0)))\n",
    "    w = np.dot(D.T, np.dot(t1, np.dot(sig.T, np.dot(U.T, y_total))))\n",
    "    pred = np.dot(testphi, w)\n",
    "\n",
    "    plt.plot(x_test, y_test, '-g', label='Actual')\n",
    "    plt.plot(x_test, pred, '-r', label='Predicted')\n",
    "    plt.title('GLM for Mauna Loa at lambda=' + str(lambda_))\n",
    "    plt.xlabel('x test')\n",
    "    plt.ylabel('y')\n",
    "    plt.legend(loc='upper left')\n",
    "    plt.savefig('maunaloa_glm2.png')\n",
    "    \n",
    "    testerror = rms_err(y_test, pred)\n",
    "\n",
    "    return testerror\n",
    "\n",
    "def validateGLM(x_train, x_valid, y_train, y_valid):\n",
    "\n",
    "    maxlambda = 21 #loop over parameters from 0 to 20\n",
    "\n",
    "    s2 = (len(x_valid), 7)\n",
    "    phival = np.empty(s2)\n",
    "    i=0\n",
    "    while i<len(x_valid):\n",
    "        phival[i, :] = basisvector(x_valid[i])  #phi matrix validation\n",
    "        i+=1\n",
    "    \n",
    "    s = (len(x_train), 7)\n",
    "    phi = np.empty(s)\n",
    "    i=0\n",
    "    while i < len(x_train):\n",
    "        phi[i, :] = basisvector(x_train[i]) #phi matrix training\n",
    "        i+=1\n",
    "        \n",
    "    #SVD\n",
    "    U, S, D = np.linalg.svd(phi)\n",
    "    sig = np.diag(S)\n",
    "    fillzeros = np.zeros([len(x_train) - len(S), len(S)])\n",
    "    sig = np.vstack([sig, fillzeros])\n",
    "\n",
    "    #get optimal lambda\n",
    "    min_rmse = 1000000\n",
    "    l=0\n",
    "    while l < maxlambda:\n",
    "        t0 = np.dot(sig.T, sig)\n",
    "        t1 = np.linalg.inv(t0 + l*np.eye(len(t0)))\n",
    "\n",
    "        w = np.dot(D.T, np.dot(t1, np.dot(sig.T, np.dot(U.T, y_train))))\n",
    "        #weight\n",
    "        predictions = np.dot(phival, w)\n",
    "        rmse_val = rms_err(y_valid, predictions)\n",
    "\n",
    "        if rmse_val < min_rmse:\n",
    "            min_rmse = rmse_val\n",
    "            bestlambda = l\n",
    "        l+=1\n",
    "\n",
    "    return bestlambda\n",
    "\n",
    "#general functions to be used multiple times\n",
    "\n",
    "def RBF(x0, x1, theta):\n",
    "    return math.exp(-((euclid(x0, x1))**2)/theta)\n",
    "\n",
    "# Error function root mean square\n",
    "def rms_err(y_t, y_e):  \n",
    "    return np.sqrt(np.average((y_t-y_e)**2))\n",
    "\n",
    "#euclidean distance\n",
    "def euclid(x1, x2):    #l2 norm\n",
    "    return np.linalg.norm([x1-x2], ord=2)\n",
    "\n",
    "#kernelized inner product\n",
    "def kernelizeIP(x1, x2):\n",
    "    return (1+x1*x2)**2 + x1*x2*math.cos(111.15*(x1-x2))\n",
    "\n",
    "#create a basis function vector\n",
    "def basisvector(x):\n",
    "    w=111.15\n",
    "    vector = list()\n",
    "    vector.append(1)\n",
    "    vector.append(x)\n",
    "    vector.append(x**2)\n",
    "    vector.append(x**3)\n",
    "    vector.append(x**4)\n",
    "    vector.append(x * math.sin(w * x))\n",
    "    vector.append(x * math.cos(w * x))\n",
    "    return np.array(vector)\n",
    "\n",
    "#Q4 code\n",
    "\n",
    "def Q4test(x_train, x_valid, x_test, y_train, y_valid, y_test, lambda_val, theta, dataset):\n",
    "\n",
    "    x_total = np.vstack([x_train, x_valid])\n",
    "    y_total = np.vstack([y_train, y_valid])\n",
    "    s = (len(x_total), len(x_total))\n",
    "    K = np.empty(s)  \n",
    "    prev = {}  \n",
    "    for i in range(len(x_total)):\n",
    "        for j in range(len(x_total)):\n",
    "            x = x_total[i]\n",
    "            y = x_total[j]\n",
    "            if str((x, y)) not in prev:\n",
    "                prev[str((x, y))] = RBF(x, y, theta)\n",
    "                prev[str((y, x))] = prev[str((x, y))]\n",
    "            K[i, j] = prev[str((x, y))] #add if not in prev\n",
    "    #print('end of Q4 test for loop 1')\n",
    "    kk = np.empty((len(x_test), len(x_total)))\n",
    "    for i in range(len(x_test)):\n",
    "        k = list()\n",
    "        vector = x_test[i]\n",
    "        for j in range(len(x_total)):\n",
    "            k.append(RBF(vector, x_total[j], theta))\n",
    "        kk[i, :] = np.array(k)\n",
    "        \n",
    "    #cholesky\n",
    "    R = np.linalg.cholesky((K + lambda_val * np.eye(len(K))))\n",
    "    Ri = np.linalg.inv(R)\n",
    "\n",
    "    alpha = np.dot(np.dot(Ri.T, Ri), y_total)\n",
    "\n",
    "    if dataset == 'mauna_loa' :\n",
    "        predictions = np.dot(kk, alpha) #dot product\n",
    "        test_rmse = rms_err(y_test, predictions) #compute error\n",
    "        \n",
    "    elif dataset == 'rosenbrock':\n",
    "        predictions = np.dot(kk, alpha) #dot product\n",
    "        test_rmse = rms_err(y_test, predictions) #compute error\n",
    "\n",
    "    else:\n",
    "        predictions = np.argmax(np.dot(kk, alpha), axis=1)\n",
    "        y_test = np.argmax(1 * y_test, axis=1)\n",
    "        test_rmse = (predictions == y_test).sum() / len(y_test)\n",
    "\n",
    "    return test_rmse\n",
    "\n",
    "def Q4valid(x_train, x_valid, y_train, y_valid, dataset):\n",
    "\n",
    "    theta_vals = [0.05, 0.1, 0.5, 1, 2]\n",
    "    lambda_vals = [0.001, 0.01, 0.1, 1]\n",
    "    result = {}\n",
    "    r = 0\n",
    "    while r<len(theta_vals):\n",
    "        #print('first while')\n",
    "        theta = theta_vals[r]\n",
    "        s = (len(x_train), len(x_train))\n",
    "        K = np.empty(s)                 \n",
    "        prev = {}                  \n",
    "        for i in range(len(x_train)):\n",
    "            #print('first for')\n",
    "            for j in range(len(x_train)):\n",
    "                x = x_train[i]\n",
    "                y = x_train[j]\n",
    "                if str((x, y)) not in prev:\n",
    "                    prev[str((x, y))] = RBF(x, y, theta)\n",
    "                    prev[str((y, x))] = prev[str((x, y))]\n",
    "                K[i, j] = prev[str((x, y))]\n",
    "        kk = np.empty((len(x_valid), len(x_train)))\n",
    "        for i in range(len(x_valid)):\n",
    "            #print('second for')\n",
    "            vector = x_valid[i]\n",
    "            k = list()\n",
    "            for j in range(len(x_train)):\n",
    "                k.append(RBF(vector, x_train[j], theta))\n",
    "            kk[i, :] = np.array(k)\n",
    "\n",
    "        for lambda_ in lambda_vals:\n",
    "            #print('third 4')\n",
    "            #cholesky\n",
    "            R = np.linalg.cholesky((K + lambda_ * np.eye(len(K))))\n",
    "            Ri = np.linalg.inv(R)\n",
    "            alpha = np.dot(np.dot(Ri.T, Ri), y_train)\n",
    "\n",
    "            if dataset == 'mauna_loa' or dataset == 'rosenbrock':\n",
    "                predictions = np.dot(kk, alpha)\n",
    "                result[(theta, lambda_)] = rms_err(y_valid, predictions)\n",
    "\n",
    "            else:\n",
    "                predictions = np.argmax(np.dot(kk, alpha), axis=1)\n",
    "                y_valid0 = np.argmax(1 * y_valid, axis=1)\n",
    "                result[(theta, lambda_)] = (predictions == y_valid0).sum() / len(y_valid0)\n",
    "        r=r+1\n",
    "    #print('end of first while')   \n",
    "    #loop and determine optimal theta and lambda\n",
    "    if dataset == 'mauna_loa' :\n",
    "        err = 1000000  #minimize rmse\n",
    "        for theta, lambda_ in result:\n",
    "            if result[(theta, lambda_)] < err:\n",
    "                err = result[(theta, lambda_)]\n",
    "                besttheta = theta\n",
    "                bestlambda = lambda_             \n",
    "    elif dataset == 'rosenbrock':\n",
    "        err = 1000000  #minimize rmse\n",
    "        for theta, lambda_ in result:\n",
    "            if result[(theta, lambda_)] < err:\n",
    "                err = result[(theta, lambda_)]\n",
    "                besttheta = theta\n",
    "                bestlambda = lambda_        \n",
    "    else: #for iris, want to maximize test ratio\n",
    "        err = -1000000\n",
    "        for theta, lambda_ in result:\n",
    "            if result[(theta, lambda_)] > err:\n",
    "                err = result[(theta, lambda_)]\n",
    "                besttheta = theta\n",
    "                bestlambda = lambda_\n",
    "\n",
    "    return besttheta, bestlambda\n",
    "\n",
    "\n",
    "#Q3 Code *************************************************\n",
    "\n",
    "def kernelizedGLM(x_train, x_valid, x_test, y_train, y_valid, y_test, lambda_):\n",
    "    \n",
    "    x_total = np.vstack([x_train, x_valid])\n",
    "    y_total = np.vstack([y_train, y_valid])\n",
    "    s = (len(x_total), len(x_total))\n",
    "    K = np.empty(s) #this will be the gram matrix\n",
    "    prev = {}                          \n",
    "    for i in range(len(x_total)):\n",
    "        for j in range(len(x_total)):\n",
    "            x = x_total[i]\n",
    "            y = x_total[j]\n",
    "            if str((x, y)) not in prev:\n",
    "                prev[str((x, y))] = kernelizeIP(x, y)\n",
    "                prev[str((y, x))] = prev[str((x, y))]\n",
    "            K[i, j] = prev[str((x, y))]  #if not in prev add to Gram\n",
    "    #cholesky\n",
    "    R = np.linalg.cholesky((K + lambda_*np.eye(len(K))))\n",
    "    Ri = np.linalg.inv(R)\n",
    "    alpha = np.dot(np.dot(Ri.T, Ri), y_total)\n",
    "    predictions = np.empty(np.shape(y_test))\n",
    "    for i in range(len(x_test)):\n",
    "        k = np.empty(np.shape(alpha)) #kernel\n",
    "        for j in range(len(x_total)):\n",
    "            k[j] = kernelizeIP(x_test[i], x_total[j])\n",
    "        predictions[i] = np.dot(k.T, alpha)  #store predictions\n",
    "\n",
    "    plt.figure(2)\n",
    "    plt.plot(x_test, y_test, '-g', label='Actual')\n",
    "    plt.plot(x_test, predictions, '-r', label='Predicted')\n",
    "    plt.title('Mauna Loa Kernelized Predictions')\n",
    "    plt.legend(loc='lower right')\n",
    "    plt.ylabel('y')\n",
    "    plt.xlabel('x_test')\n",
    "    i=0\n",
    "    while i<2:\n",
    "        y_vals = list()\n",
    "        z = np.linspace(-0.1 + i, 0.1 + i, 100) #bounds\n",
    "        z = np.array(z)\n",
    "        for elem in z:\n",
    "            y_vals.append(kernelizeIP(i, elem))\n",
    "        plt.figure(i + 3)\n",
    "        plt.plot(z, y_vals, '-r', label='kernel')\n",
    "        plt.title('kernel(' + str(i) + ', z+' + str(i) + ') over z')\n",
    "        plt.ylabel('k')\n",
    "        plt.xlabel('z')\n",
    "        i+=1\n",
    "       \n",
    "    test_rmse = rms_err(y_test, predictions)\n",
    "    \n",
    "    return test_rmse\n",
    "\n",
    "#Q5 Code ******************************************************************\n",
    "\n",
    "def orthogonalmatching(x_train,y_train,theta,kk):\n",
    "    res=-1*y_train\n",
    "    options=np.zeros((len(x_train),len(x_train)))\n",
    "    for i in range(0,len(x_train)):\n",
    "            options[i]=np.exp(-1*(np.linalg.norm(x_train-x_train[i],axis=1)**2)/theta)\n",
    "    fn=np.array([])\n",
    "    w=np.array([])\n",
    "    kvals=[]\n",
    "    MDL=[]\n",
    "    k=1\n",
    "    i=0\n",
    "    while i<kk:\n",
    "        fn,w=helper(x_train,y_train,options,selected,res,w,theta)\n",
    "        minus=np.zeros((len(x_train),len(fn)))\n",
    "        for j in range(0,len(x_train)):\n",
    "            minus[j]=np.exp(-1*(np.linalg.norm(fn-x_train[j],axis=1)**2)/theta)\n",
    "        res=y_train-np.dot(minus,w)\n",
    "        MDL.append(0.5*len(x_train)*np.log(np.sum(np.square(res)))+0.5*k*np.log(len(x_train)))\n",
    "        kvals.append(k)\n",
    "        k=k+1\n",
    "        i=i+1\n",
    "    K=np.zeros((len(x_test),len(fn)))\n",
    "    i=0\n",
    "    while i<len(x_test):\n",
    "        j=0\n",
    "        while j <len(fn):\n",
    "            K[i][j]=np.sum(np.square(np.subtract(x_test[i],fn[j])))   \n",
    "            j=j+1\n",
    "        i=i+1\n",
    "    test_K=np.exp(-1*K/theta)\n",
    "    pred=np.dot(test_K,w)\n",
    "    plt.plot(np.array(kvals),np.array(MDL), '-g', label='MDL Val')\n",
    "    plt.title(\"Complexity (k) vs MDL Value\")\n",
    "    plt.xlabel(\"Complexity (k)\")\n",
    "    plt.ylabel(\"Minimum Description Length Value\")\n",
    "    \n",
    "    err=rms_err(y_test,pred)\n",
    "    \n",
    "    return err\n",
    "    \n",
    "def helper(x_train,y_train,options,fn,res,w,theta):\n",
    "    prev=0\n",
    "    i=0\n",
    "    while i<len(options[0]):\n",
    "        update=(np.dot(res.transpose(),options[:,i].transpose())**2)/(np.dot(options[:,i],options[:,i].transpose()))\n",
    "        if(update[0]>prev):\n",
    "            prev=update[0]\n",
    "            idx=i\n",
    "        i=i+1\n",
    "    if(len(w)==0):\n",
    "        fn=np.array(np.array(x_train[np.where(options[:,idx]==1)]))\n",
    "    else:\n",
    "        fn=np.vstack((fn,x_train[np.where(options[:,idx]==1)]))\n",
    "    phi=np.zeros((len(x_train),len(fn)))\n",
    "    #use qr factorization this time\n",
    "    i=0\n",
    "    while i<len(x_train):\n",
    "            phi[i]=np.exp(-1*(np.linalg.norm(fn-x_train[i],axis=1)**2)/theta)\n",
    "            i=i+1\n",
    "    q,r=np.linalg.qr(phi)\n",
    "    w=np.dot(np.linalg.inv(r),np.dot(q.transpose(),y_train))\n",
    "    options=np.delete(options,idx,1)\n",
    "    return fn,w\n",
    "\n",
    "\n",
    "#MAIN**********************************************\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    regression = ['mauna_loa', 'rosenbrock', 'pumadyn32nm']\n",
    "    classification = ['iris', 'mnist_small']\n",
    "    \n",
    "if Q2:\n",
    "\n",
    "    print('Question 2')\n",
    "    print('')\n",
    "    x_train, x_valid, x_test, y_train, y_valid, y_test = load_dataset('mauna_loa')\n",
    "    lambda_ = validateGLM(x_train, x_valid, y_train, y_valid)\n",
    "    test_rmse = testGLM(x_train, x_valid, x_test, y_train, y_valid, y_test, lambda_)\n",
    "    print('Optimal Lambda: ' + str(lambda_))\n",
    "    print('Test RMSE: ' + str(test_rmse))\n",
    "    print('')\n",
    "    \n",
    "if Q3:\n",
    "\n",
    "    print('Question 3')\n",
    "    print('')\n",
    "    \n",
    "    x_train, x_valid, x_test, y_train, y_valid, y_test = load_dataset('mauna_loa')\n",
    "    test_rmse = kernelizedGLM(x_train, x_valid, x_test, y_train, y_valid, y_test, 1)\n",
    "    \n",
    "    visualize_kernel()\n",
    "    \n",
    "    print('Test RMSE: ' + str(test_rmse))\n",
    "    print('')\n",
    "    \n",
    "if Q4: \n",
    "\n",
    "    print('Question 4')\n",
    "    print('')\n",
    "    \n",
    "    x_train, x_valid, x_test, y_train, y_valid, y_test = load_dataset('rosenbrock', n_train=1000, d=2)\n",
    "    theta, reg = Q4valid(x_train, x_valid, y_train, y_valid, 'rosenbrock')\n",
    "    test_rmse = Q4test(x_train, x_valid, x_test, y_train, y_valid, y_test, reg, theta, 'rosenbrock')\n",
    "    print('Rosenbrock')\n",
    "    print('Optimal Theta: ' + str(theta))\n",
    "    print('Optimal Lambda: ' + str(reg))\n",
    "    print('Test Error: ' + str(test_rmse))\n",
    "    print('')\n",
    "    \n",
    "    x_train, x_valid, x_test, y_train, y_valid, y_test = load_dataset('mauna_loa')\n",
    "    theta, reg = Q4valid(x_train, x_valid, y_train, y_valid, 'mauna_loa')\n",
    "    test_rmse = Q4test(x_train, x_valid, x_test, y_train, y_valid, y_test, reg, theta, 'mauna_loa')\n",
    "    print('Mauna Loa')\n",
    "    print('Optimal Theta: ' + str(theta))\n",
    "    print('Optimal Lambda: ' + str(reg))\n",
    "    print('Test Error: ' + str(test_rmse))\n",
    "    print('')\n",
    "\n",
    "\n",
    "    x_train, x_valid, x_test, y_train, y_valid, y_test = load_dataset('iris')\n",
    "    theta, reg = Q4valid(x_train, x_valid, y_train, y_valid, 'iris')\n",
    "    test_ratio = Q4test(x_train, x_valid, x_test, y_train, y_valid, y_test, reg, theta, 'iris')\n",
    "    print('Iris')\n",
    "    print('Optimal Theta: ' + str(theta))\n",
    "    print('Optimal Lambda: ' + str(reg))\n",
    "    print('Test Accuracy Ratio: ' + str(test_ratio))\n",
    "    print('')\n",
    "    \n",
    "    \n",
    "if Q5:\n",
    "    \n",
    "    print('Question 5')\n",
    "    print('')\n",
    "    \n",
    "    x_train, x_valid, x_test, y_train, y_valid, y_test = load_dataset('rosenbrock', n_train=200, d=2)\n",
    "    err =orthogonalmatching(np.vstack((x_train,x_valid)),np.vstack((y_train,y_valid)),0.1,1000)\n",
    "    print('Test Error: ' + str(err))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
